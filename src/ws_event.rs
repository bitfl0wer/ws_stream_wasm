use crate::{ import::* };


/// Events related to the WebSocket
//
#[ derive( Clone, Debug, PartialEq, Eq ) ]
//
pub enum WsEvent
{
	/// The connection was closed. This enclosed CloseEvent has some extra information.
	//
	Close( CloseEvent ),

	/// The connection has started closing, but is not closed yet.
	//
	Closing,

	/// An error happened on the connection. For more information about when this event
	/// occurs, see the [HTML Living Standard](https://html.spec.whatwg.org/multipage/web-sockets.html).
	//
	Error,

	/// The connection is now Open
	//
	Open,
}



impl WsEvent
{
	/// Allows easy comparing of the discriminant of WsEvent
	//
	pub fn ws_type( &self ) -> WsEventType
	{
		match self
		{
			Self::Close(_) => WsEventType::CLOSE   ,
			Self::Closing  => WsEventType::CLOSING ,
			Self::Open     => WsEventType::OPEN    ,
			Self::Error    => WsEventType::ERROR   ,
		}
	}
}




/// An event holding information about how the connection was closed.
///
// We use this wrapper because the web_sys version isn't Send and pharos requires events
// to be Send.
//
#[ derive( Clone, Debug, PartialEq, Eq ) ]
//
pub struct CloseEvent
{
	/// The close code
	/// See: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close)
	//
	pub code     : u16    ,

	/// The reason why the connection was closed
	/// See: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close)
	//
	pub reason   : String ,

	/// Whether the connection was closed cleanly
	/// See: [MDN Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close)
	//
	pub was_clean: bool   ,
}


impl From<JsCloseEvt> for CloseEvent
{
	fn from( js_evt: JsCloseEvt ) -> Self
	{
		Self
		{
			code     : js_evt.code     () ,
			reason   : js_evt.reason   () ,
			was_clean: js_evt.was_clean() ,
		}
	}
}




bitflags!
{
	/// The different types of events a WebSocket can generate. This is used for filtering in
	/// [NextEvent].
	//
	pub struct WsEventType: u8
	{
		/// Open
		//
		const OPEN    = 0b0001;

		/// Closing
		//
		const CLOSING = 0b0010;

		/// Close
		//
		const CLOSE   = 0b0100;

		/// Error
		//
		const ERROR   = 0b1000;
	}
}



/// Future that resolves to the next WsEvent filtered to the type(s) you want.
///
/// ## Examples
///
/// Get the next close event:
/// ```rust
/// #![ feature( async_await ) ]
///
/// use
/// {
///    async_runtime  :: rt             , // from crate naja_async_runtime
///    ws_stream_wasm :: *              ,
///    pharos         :: *              ,
///    wasm_bindgen   :: UnwrapThrowExt ,
/// };
///
/// let program = async
/// {
///    let (mut ws, wsio) = WsStream::connect( "127.0.0.1:3012", None ).await
///
///       .expect_throw( "assume the connection succeeds" );
///
///    // This will resolve once a close event is generated by the WebSocket:
///    //
///    NextEvent::new( ws.observe_unbounded(), WsEventType::CLOSE ).await;
/// };
///
/// rt::spawn_local( program ).expect_throw( "spawn program " );
/// ```
//
#[ allow( clippy::type_complexity ) ]
//
pub struct NextEvent
{
	rx: FilterMap<UnboundedReceiver<WsEvent>, Ready<Option<WsEvent>>, Box<dyn FnMut(WsEvent)->Ready<Option<WsEvent>>> >
}


impl NextEvent
{
	/// Create a new NextEvent future. If you are only interested in a specific type of event,
	/// you can use the filter parameter to get the next event of that type.
	//
	pub fn new( rx: UnboundedReceiver<WsEvent>, filter: impl Into<Option<WsEventType>> ) -> Self
	{
		let mut filter = filter.into();

		if filter.is_none() { filter = Some( WsEventType::all() ) }

		let filter = filter.unwrap();


		Self
		{
			rx: rx.filter_map( Box::new( move |evt|
			{
				match evt
				{
					WsEvent::Open     if filter.contains( WsEventType::OPEN    ) => ready( Some( evt ) ),
					WsEvent::Closing  if filter.contains( WsEventType::CLOSING ) => ready( Some( evt ) ),
					WsEvent::Close(_) if filter.contains( WsEventType::CLOSE   ) => ready( Some( evt ) ),
					WsEvent::Error    if filter.contains( WsEventType::ERROR   ) => ready( Some( evt ) ),
					_                                                            => ready( None        ),
				}
			}))
		}
	}
}


impl Future for NextEvent
{
	type Output = Option<WsEvent>;

	fn poll( mut self: Pin<&mut Self>, cx: &mut Context<'_> ) -> Poll<Self::Output>
	{
		let evt = ready!( Pin::new( &mut self.rx ).poll_next(cx) );

		Poll::Ready( evt )
	}
}



impl fmt::Debug for NextEvent
{
	fn fmt( &self, f: &mut fmt::Formatter<'_> ) -> fmt::Result
	{
		write!( f, "ws_stream_wasm::NextEvent" )
	}
}

